/**
 * @file Blurt Condenser API helpers.
 * @author BeBlurt <https://beblurt.com/@beblurt>
 * @description adaptation from Johan Nordberg <code@johan-nordberg.com> Database API helpers.
 * @license
 * Copyright (c) 2022 BeBlurt. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * You acknowledge that this software is not designed, licensed or intended for use
 * in the design, construction, operation or maintenance of any military facility.
 */
import { ExtendedAccount } from '../chain/account';
import { BlockHeader, SignedBlock } from '../chain/block';
import { BlogEntry } from '../chain/blog';
import { Post, Discussion } from '../chain/comment';
import { DynamicGlobalProperties, ChainProperties, RpcNodeConfig, VestingDelegation, RewardFund } from '../chain/misc';
import { AppliedOperation } from '../chain/operation';
import { Proposal, ProposalVote } from '../chain/proposal';
import { SignedTransaction } from '../chain/transaction';
import { Witness } from '../chain/witness';
import { Client } from '../client';
/** Possible categories for `get_discussions_by_*`. */
export declare type DiscussionQueryCategory = 'active' | 'blog' | 'cashout' | 'children' | 'comments' | 'feed' | 'hot' | 'promoted' | 'trending' | 'votes' | 'created';
export interface DisqussionQuery {
    /** Name of author or tag to fetch. */
    tag?: string;
    /** Number of results, max 100. */
    limit: number;
    filter_tags?: string[];
    select_authors?: string[];
    select_tags?: string[];
    /** Number of bytes of post body to fetch, default 0 (all) */
    truncate_body?: number;
    /**
     * Name of author to start from, used for paging.
     * Should be used in conjunction with `start_permlink`.
     */
    start_author?: string;
    /**
     * Permalink of post to start from, used for paging.
     * Should be used in conjunction with `start_author`.
     */
    start_permlink?: string;
    parent_author?: string;
    parent_permlink?: string;
}
export interface FollowCount {
    account: string;
    follower_count: number;
    following_count: number;
}
export interface Followers {
    follower: string;
    following: string;
    what: ['blog' | 'ignore' | null];
}
export interface Following {
    follower: string;
    following: string;
    what: ['blog' | 'ignore' | null];
}
export declare class CondenserAPI {
    readonly client: Client;
    constructor(client: Client);
    /** Convenience for calling `condenser_api`. */
    call(method: string, params?: any[] | {
        [key: string]: any;
    }): Promise<any>;
    /**
     * Returns one or more account history objects for account operations
     *
     * @param account The account to fetch
     * @param from The starting index
     * @param limit The maximum number of results to return
     * @param operations_bitmask Generated by utils.makeBitMaskFilter() - see example below (not yet usable)
     * @example
     * ```typescript
     * import { utils } from "@beblurt/dblurt"
     * const op = dblurt.utils.operationOrders
     * const operationsBitmask = dblurt.utils.makeBitMaskFilter([
     *   op.vote,
     *   op.comment,
     *   op.delete_comment,
     *   op.comment_options,
     *   op.claim_reward_balance,
     *   op.author_reward,
     *   op.curation_reward,
     *   op.comment_reward,
     *   op.producer_reward,
     * ])
     * const accountHistory = await client.condenser.getAccountHistory('beblurt', -1, 10, operationsBitmask)
     * ```
     */
    getAccountHistory(account: string, from: number, limit: number, operation_bitmask?: (number | null)[]): Promise<[[number, AppliedOperation]]>;
    /** Return array of account info objects for the usernames passed. @param usernames The accounts to fetch. */
    getAccounts(usernames: string[]): Promise<ExtendedAccount[]>;
    /** Returns all votes for the given post. */
    getActiveVotes(author: string, permlink: string): Promise<Post['active_votes']>;
    /** Returns the list of active witnesses */
    getActiveWitnesses(): Promise<Witness[]>;
    /** Return block *blockNum*. */
    getBlock(blockNum: number): Promise<SignedBlock>;
    /** Return header for *blockNum*. */
    getBlockHeader(blockNum: number): Promise<BlockHeader>;
    /** Returns a list of blog entries for an account. */
    getBlogEntries(account: string, start_entry_id: number, limit: number): Promise<BlogEntry[]>;
    /** Return median chain properties decided by witness. */
    getChainProperties(): Promise<ChainProperties>;
    /** Return server config. See:
     * https://gitlab.com/blurt/blurt/-/blob/master/libraries/protocol/include/blurt/protocol/config.hpp
     */
    getConfig(): Promise<RpcNodeConfig>;
    /** Returns a content (post or comment). */
    getContent(author: string, permlink: string): Promise<Post>;
    /** Returns a list of replies. */
    getContentReplies(author: string, permlink: string): Promise<Post[]>;
    /** Return Dynamic Global Properties. */
    getDynamicGlobalProperties(): Promise<DynamicGlobalProperties>;
    /**
     * Return array of discussions (a.k.a. posts).
     * @param by The type of sorting for the discussions, valid options are:
     *           `active` `blog` `cashout` `children` `comments` `created`
     *           `feed` `hot` `promoted` `trending` `votes`. Note that
     *           for `blog` and `feed` the tag is set to a username.
     */
    getDiscussions(by: DiscussionQueryCategory, query: DisqussionQuery): Promise<Discussion[]>;
    /** return the count of followers/following for an account */
    getFollowCount(accounts: string[]): Promise<FollowCount>;
    /** return the list of the followers of an account */
    getFollowers(account: string, start: string | null, type: 'blog' | 'ignore' | null, limit: number): Promise<Followers[]>;
    /** return the list of accounts that are following an account */
    getFollowing(account: string, start: string | null, type: 'blog' | 'ignore' | null, limit: number): Promise<Following[]>;
    /** Returns the list of accounts that are reblogged a content (post). */
    getRebloggedBy(author: string, permlink: string): Promise<string[]>;
    /** Return all applied operations in *blockNum*. */
    getOperations(blockNum: number, onlyVirtual?: boolean): Promise<AppliedOperation[]>;
    /**
     * Returns an array of proposals filtered by the specified parameters.
     * @param start - Depends on order (see below)
     * - creator - creator of the proposal (account name string)
     * - start_date - start date of the proposal (date string)
     * - end_date - end date of the proposal (date string)
     * - total_votes - total votes of the proposal (int)
     * @param limit - The maximum number of proposals to return (max 1000).
     * @param order - can be one of:
     * - by_creator - order by proposal creator
     * - by_start_date - order by proposal start date
     * - by_end_date - order by proposal end date
     * - by_total_votes - order by proposal total votes
     * @param order_direction - The direction in which to order the results. Can be ascending or descending
     * @param status - The status of proposals to return.
     * @returns A Promise that resolves to an array of Proposal objects.
     */
    getProposals(start: string[] | number[], limit: number, order: 'by_creator' | 'by_start_date' | 'by_end_date' | 'by_total_votes', order_direction: 'ascending' | 'descending', status: 'all' | 'inactive' | 'active' | 'expired' | 'votable'): Promise<Proposal[]>;
    /**
     * Returns all proposal votes, starting with the specified voter or proposal.id.
     * @param start - Depends on order (see below)
     * - voter - voter of the proposal (account name string)
     * - proposal.id - id the proposal (int)
     * @param limit - The maximum number of proposals to return (max 1000).
     * @param order - can be one of:
     * - by_voter_proposal - order by proposal voter
     * - by_proposal_voter - order by proposal.id
     * @param order_direction - The direction in which to order the results. Can be ascending or descending
     * @param status - The status of proposals to return.
     * @returns A Promise that resolves to an array of ProposalVote objects.
     */
    getProposalVotes(start: string[] | number[], limit: number, order: 'by_voter_proposal' | 'by_proposal_voter', order_direction: 'ascending' | 'descending', status: 'all' | 'inactive' | 'active' | 'expired' | 'votable'): Promise<ProposalVote[]>;
    /** Returns information about the current reward funds */
    getRewardFund(fund: 'post'): Promise<RewardFund>;
    /**
     * Return all of the state required for a particular url path.
     * @param path Path component of url conforming to condenser's scheme
     *             e.g. `@beblurt` or `trending/travel`
     */
    getState(path: string): Promise<any>;
    /** Returns the details of a transaction based on a transaction id. */
    getTransaction(txId: string): Promise<SignedTransaction>;
    /** return rpc node version */
    getVersion(): Promise<object>;
    /**
     * Get list of delegations made by account.
     * @param account Account delegating
     * @param from Delegatee start offset, used for paging.
     * @param limit Number of results, max 1000.
     */
    getVestingDelegations(account: string, from?: string, limit?: number): Promise<VestingDelegation[]>;
    /** Returns the current witness schedule */
    getWitnesseSchedule(): Promise<Witness[]>;
    /** Returns the current number of witnesses */
    getWitnessesCount(): Promise<Witness[]>;
    /** Returns current witnesses by vote */
    getWitnessesByVote(account: string | null, limit: number): Promise<Witness[]>;
    /** Looks up accounts starting with name */
    lookupAccounts(account: string, limit: number): Promise<string[]>;
    /** Looks up accounts starting with name */
    lookupWitnessAccounts(account: string, limit: number): Promise<string[]>;
    /** Verify signed transaction. */
    verifyAuthority(stx: SignedTransaction): Promise<boolean>;
}
