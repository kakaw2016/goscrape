"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cryptoUtils = exports.encodeMemo = exports.decodeMemo = exports.Signature = exports.PrivateKey = exports.PublicKey = void 0;
/**
 * @file Blurt crypto helpers.
 * @author BeBlurt <https://beblurt.com/@beblurt>
 * @description adaptation from Johan Nordberg <code@johan-nordberg.com> crypto helpers.
 * @license
 * Copyright (c) 2017 Johan Nordberg. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * You acknowledge that this software is not designed, licensed or intended for use
 * in the design, construction, operation or maintenance of any military facility.
 */
const assert_1 = __importDefault(require("assert"));
const crypto_1 = require("crypto");
const bs58_1 = __importDefault(require("bs58"));
const bigi_1 = __importDefault(require("bigi"));
// eslint-disable-next-line import/order
const ByteBuffer = require('bytebuffer');
const Long = ByteBuffer.Long;
const secp256k1 = __importStar(require("secp256k1"));
const ecurve_1 = require("ecurve");
const verror_1 = require("verror");
const serializer_1 = require("./chain/serializer");
const deserializer_1 = require("./chain/deserializer");
const client_1 = require("./client");
const utils_1 = require("./utils");
/** Network id used in WIF-encoding */
const NETWORK_ID = Buffer.from([0x80]);
/** Regexp for a graphene account */
const regExpAccount = /^(?=.{3,16}$)[a-z][0-9a-z\-]{1,}[0-9a-z]([\.][a-z][0-9a-z\-]{1,}[0-9a-z]){0,}$/;
/** Regexp for a graphene account with @ */
const regExpAtAccount = /^@(?=.{3,16}$)[a-z][0-9a-z\-]{1,}[0-9a-z]([\.][a-z][0-9a-z\-]{1,}[0-9a-z]){0,}$/;
/** From Buffer to Uint8Array */
const toUint8Array = (buf) => {
    const ab = new ArrayBuffer(buf.length);
    const view = new Uint8Array(ab);
    for (let i = 0; i < buf.length; ++i) {
        view[i] = buf[i];
    }
    return view;
};
/** From ArrayBuffer to Buffer */
const toBuffer = (ab) => {
    const buf = Buffer.alloc(ab.byteLength);
    const view = new Uint8Array(ab);
    for (let i = 0; i < buf.length; ++i) {
        buf[i] = view[i];
    }
    return buf;
};
/**
 * Converts a string, number or Long to a ByteBuffer object.
 *
 * @param o - The value to be converted.
 * @returns A ByteBuffer object.
 * @throws An error if the input is not a string, number or Long.
 */
const toByteBuffer = (o) => {
    if (typeof o === 'string') {
        return Long.fromString(o);
    }
    else if (typeof o === 'number') {
        return Long.fromNumber(o);
    }
    else if (o instanceof ByteBuffer.Long) {
        return o;
    }
    else {
        throw new Error('Input is not a string, number or Long');
    }
};
/**
 * Generates a unique 64 bit unsigned number string. Being time based,
 * this is careful to never choose the same nonce twice. This value could
 * be recorded in the blockchain for a long time.
 * @returns The unique nonce.
 */
let unique_nonce_entropy = Math.floor(Math.random() * 0xFFFF);
const uniqueNonce = () => {
    let long = BigInt(Date.now());
    const entropy = ++unique_nonce_entropy % 0xFFFF;
    if (entropy === 0) {
        const last = Number(long >> BigInt(16));
        const now = Date.now();
        if (now <= last) {
            long += BigInt(1);
        }
        unique_nonce_entropy = 0;
    }
    long = (long << BigInt(16)) | BigInt(entropy);
    return long.toString(16).padStart(16, '0');
};
/** Return ripemd160 hash of input */
const ripemd160 = (input) => crypto_1.createHash('ripemd160').update(input).digest();
/** Return sha256 hash of input */
const sha256 = (input) => crypto_1.createHash('sha256').update(input).digest();
/** Return 2-round sha256 hash of input */
const doubleSha256 = (input) => sha256(sha256(input));
/** Encode public key with bs58+ripemd160-checksum */
const encodePublic = (key, prefix) => {
    const checksum = ripemd160(key);
    return prefix + bs58_1.default.encode(Buffer.concat([key, toUint8Array(checksum).slice(0, 4)]));
};
/** Decode bs58+ripemd160-checksum encoded public key */
const decodePublic = (encodedKey) => {
    const prefix = encodedKey.slice(0, 3);
    encodedKey = encodedKey.slice(3);
    const uint8Array = bs58_1.default.decode(encodedKey);
    const checksum = uint8Array.slice(-4);
    const key = uint8Array.slice(0, -4);
    const bufKey = Buffer.from(key);
    const checksumVerify = toUint8Array(ripemd160(bufKey)).slice(0, 4);
    if (Buffer.compare(toBuffer(checksumVerify), toBuffer(checksum)) !== 0) {
        throw new Error('public key checksum mismatch');
    }
    return { key: bufKey, prefix };
};
/** Encode bs58+doubleSha256-checksum private key */
const encodePrivate = (key) => {
    assert_1.default.strictEqual(key.readUInt8(0), 0x80, 'private key network id mismatch');
    const checksum = doubleSha256(key);
    return bs58_1.default.encode(Buffer.concat([key, toUint8Array(checksum).slice(0, 4)]));
};
/** Decode bs58+doubleSha256-checksum encoded private key */
const decodePrivate = (encodedKey) => {
    const uint8Array = bs58_1.default.decode(encodedKey);
    const toCompare = toBuffer(uint8Array.slice(0, 1));
    if (Buffer.compare(NETWORK_ID, toCompare) !== 0) {
        throw new Error('private key network id mismatch');
    }
    const checksum = uint8Array.slice(-4);
    const key = uint8Array.slice(0, -4);
    const bufKey = Buffer.from(key);
    const dSha256 = sha256(sha256(bufKey));
    const checksumVerify = toUint8Array(dSha256).slice(0, 4);
    if (Buffer.compare(toBuffer(checksumVerify), toBuffer(checksum)) !== 0) {
        throw new Error('private key checksum mismatch');
    }
    return bufKey;
};
/** Return true if signature is canonical, otherwise false */
const isCanonicalSignature = (signature) => (!(signature[0] & 0x80) &&
    !(signature[0] === 0 && !(signature[1] & 0x80)) &&
    !(signature[32] & 0x80) &&
    !(signature[32] === 0 && !(signature[33] & 0x80)));
/** Return true if string is wif, otherwise false */
const isWif = (privWif) => {
    try {
        const bufWif = Buffer.from(bs58_1.default.decode(privWif));
        const privKey = toUint8Array(bufWif).slice(0, -4);
        const checksum = toUint8Array(bufWif).slice(-4);
        let newChecksum = sha256(toBuffer(privKey));
        newChecksum = sha256(newChecksum);
        newChecksum = toBuffer(toUint8Array(newChecksum).slice(0, 4));
        return (checksum.toString() === newChecksum.toString());
    }
    catch (e) {
        return false;
    }
};
/**
 * ECDSA (secp256k1) public key.
 */
class PublicKey {
    constructor(key, prefix = client_1.DEFAULT_ADDRESS_PREFIX) {
        this.key = key;
        this.prefix = prefix;
        assert_1.default(secp256k1.publicKeyVerify(key), 'invalid public key');
        this.uncompressed = Buffer.from(secp256k1.publicKeyConvert(key, false));
    }
    /**
     * Create a new instance from a WIF-encoded key.
     */
    static fromString(wif) {
        const { key, prefix } = decodePublic(wif);
        return new PublicKey(key, prefix);
    }
    static fromBuffer(key) {
        assert_1.default(secp256k1.publicKeyVerify(key), 'invalid buffer as public key');
        return { key };
    }
    /**
     * Create a new instance.
     */
    static from(value) {
        if (value instanceof PublicKey) {
            return value;
        }
        else {
            return PublicKey.fromString(value);
        }
    }
    /**
     * Verify a 32-byte signature.
     * @param message 32-byte message to verify.
     * @param signature Signature to verify.
     */
    verify(message, signature) {
        return secp256k1.ecdsaVerify(signature.data, message, this.key);
    }
    /**
     * Return a WIF-encoded representation of the key.
     */
    toString() {
        return encodePublic(this.key, this.prefix);
    }
    /**
     * Return JSON representation of this key, same as toString().
     */
    toJSON() {
        return this.toString();
    }
    /**
     * Used by `utils.inspect` and `console.log` in node.js.
     */
    inspect() {
        return `PublicKey: ${this.toString()}`;
    }
}
exports.PublicKey = PublicKey;
/**
 * ECDSA (secp256k1) private key.
 */
class PrivateKey {
    constructor(key) {
        this.key = key;
        assert_1.default(secp256k1.privateKeyVerify(key), 'invalid private key');
    }
    /**
     * Convenience to create a new instance from WIF string or buffer.
     */
    static from(value) {
        if (typeof value === 'string') {
            return PrivateKey.fromString(value);
        }
        else {
            return new PrivateKey(value);
        }
    }
    /**
     * Create a new instance from a WIF-encoded key.
     */
    static fromString(wif) {
        const decoded = toUint8Array(decodePrivate(wif)).slice(1);
        return new PrivateKey(toBuffer(decoded));
    }
    /**
     * Create a new instance from a seed.
     */
    static fromSeed(seed) {
        return new PrivateKey(sha256(seed));
    }
    /**
     * Create key from username and password.
     */
    static fromLogin(username, password, role = 'active') {
        const seed = username + role + password;
        return PrivateKey.fromSeed(seed);
    }
    /**
     * Sign message.
     * @param message 32-byte message.
     */
    sign(message) {
        let rv;
        let attempts = 0;
        do {
            const options = {
                data: sha256(Buffer.concat([message, Buffer.alloc(1, ++attempts)]))
            };
            rv = secp256k1.ecdsaSign(message, this.key, options);
        } while (!isCanonicalSignature(toBuffer(rv.signature)));
        return new Signature(toBuffer(rv.signature), rv.recid);
    }
    /**
     * Derive the public key for this private key.
     */
    createPublic(prefix) {
        return new PublicKey(toBuffer(secp256k1.publicKeyCreate(this.key)), prefix);
    }
    /**
     * Return a WIF-encoded representation of the key.
     */
    toString() {
        return encodePrivate(Buffer.concat([NETWORK_ID, this.key]));
    }
    /**
     * Get shared secret for memo cryptography
     */
    getSharedSecret(publicKey) {
        const KBP = ecurve_1.Point.fromAffine(ecurve_1.getCurveByName('secp256k1'), bigi_1.default.fromBuffer(publicKey.uncompressed.slice(1, 33)), bigi_1.default.fromBuffer(publicKey.uncompressed.slice(33, 65)));
        const P = KBP.multiply(bigi_1.default.fromBuffer(this.key));
        const S = P.affineX.toBuffer(32);
        return crypto_1.createHash('sha512').update(S).digest();
    }
    /**
     * Used by `utils.inspect` and `console.log` in node.js. Does not show the full key
     * to get the full encoded key you need to explicitly call {@link toString}.
     */
    inspect() {
        const key = this.toString();
        return `PrivateKey: ${key.slice(0, 6)}...${key.slice(-6)}`;
    }
}
exports.PrivateKey = PrivateKey;
/**
 * ECDSA (secp256k1) signature.
 */
class Signature {
    constructor(data, recovery) {
        this.data = data;
        this.recovery = recovery;
        assert_1.default.strictEqual(data.length, 64, 'invalid signature');
    }
    static fromBuffer(buffer) {
        assert_1.default.strictEqual(buffer.length, 65, 'invalid signature');
        const recovery = buffer.readUInt8(0) - 31;
        const data = toUint8Array(buffer).slice(1);
        return new Signature(toBuffer(data), recovery);
    }
    static fromString(string) {
        return Signature.fromBuffer(Buffer.from(string, 'hex'));
    }
    /**
     * Recover public key from signature by providing original signed message.
     * @param message 32-byte message that was used to create the signature.
     */
    recover(message, prefix) {
        return new PublicKey(toBuffer(secp256k1.ecdsaRecover(this.data, this.recovery, message)), prefix);
    }
    toBuffer() {
        const buffer = Buffer.alloc(65);
        buffer.writeUInt8(this.recovery + 31, 0);
        this.data.copy(buffer, 1);
        return buffer;
    }
    toString() {
        return this.toBuffer().toString('hex');
    }
}
exports.Signature = Signature;
/**
 * Return the sha256 transaction digest.
 * @param chainId The chain id to use when creating the hash.
 */
const transactionDigest = (transaction, chainId = client_1.DEFAULT_CHAIN_ID) => {
    const buffer = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
    try {
        serializer_1.Types.Transaction(buffer, transaction);
    }
    catch (cause) {
        throw new verror_1.VError({ cause, name: 'SerializationError' }, 'Unable to serialize transaction');
    }
    buffer.flip();
    const transactionData = Buffer.from(buffer.toBuffer());
    const digest = sha256(Buffer.concat([chainId, transactionData]));
    return digest;
};
/**
 * Return copy of transaction with signature appended to signatures array.
 * @param transaction Transaction to sign.
 * @param keys Key(s) to sign transaction with.
 * @param options Chain id and address prefix, compatible with {@link Client}.
 */
// eslint-disable-next-line max-len
const signTransaction = (transaction, keys, chainId = client_1.DEFAULT_CHAIN_ID) => {
    const digest = transactionDigest(transaction, chainId);
    const signedTransaction = utils_1.copy(transaction);
    if (!signedTransaction.signatures) {
        signedTransaction.signatures = [];
    }
    if (!Array.isArray(keys)) {
        keys = [keys];
    }
    for (const key of keys) {
        const signature = key.sign(digest);
        signedTransaction.signatures.push(signature.toString());
    }
    return signedTransaction;
};
const generateTrxId = (transaction) => {
    const buffer = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
    try {
        serializer_1.Types.Transaction(buffer, transaction);
    }
    catch (cause) {
        throw new verror_1.VError({ cause, name: 'SerializationError' }, 'Unable to serialize transaction');
    }
    buffer.flip();
    const transactionData = Buffer.from(buffer.toBuffer());
    return exports.cryptoUtils.sha256(transactionData).toString('hex').slice(0, 40);
};
/**
 * Memo Encode/Decode
 */
/**
 * remove varint length prefix
 *
 * @param decryptedMessage - Buffer of the decrypted message
 * @returns the decrypted message minus the varint length prefix
 */
const removeVarintLengthPrefix = (decryptedMessage) => {
    const mbuf = ByteBuffer.fromBinary(decryptedMessage.toString('binary'), ByteBuffer.LITTLE_ENDIAN);
    try {
        mbuf.mark();
        return '#' + mbuf.readVString();
    }
    catch (e) {
        mbuf.reset();
        // Sender did not length-prefix the memo
        const memo = Buffer.from(mbuf.toString('binary'), 'binary').toString('utf-8');
        return '#' + memo;
    }
};
/**
 * Decrypts an encrypted memo.
 *
 * @param memo - The encrypted memo to decrypt (need to start with #).
 * @param receiverPrivateMemoKey - The private Memo key of the recipient.
 * @returns The decrypted message.
 */
exports.decodeMemo = (memo, receiverPrivateMemoKey) => {
    try {
        assert_1.default(typeof receiverPrivateMemoKey === 'string' || receiverPrivateMemoKey.toString(), 'Invalid Receiver private MEMO key!');
        if (!memo.startsWith('#')) {
            return memo;
        }
        const privateKey = typeof receiverPrivateMemoKey === 'string' ? PrivateKey.from(receiverPrivateMemoKey) : receiverPrivateMemoKey;
        memo = memo.substring(1);
        const memoBuff = bs58_1.default.decode(memo);
        const deserialized = deserializer_1.EncryptedMemoDeserializer(Buffer.from(memoBuff));
        // const { from, to, nonce, check, encrypted } = deserialized
        const { from, nonce, check, encrypted } = deserialized;
        const publicKey = new PublicKey(from.key);
        const nonceLong = toByteBuffer(nonce);
        // Appending nonce to buffer "ebuf" and rehash with sha512
        const S = privateKey.getSharedSecret(publicKey);
        let ebuf = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        ebuf.writeUint64(nonceLong);
        ebuf.append(S.toString('binary'), 'binary');
        ebuf = Buffer.from(ebuf.copy(0, ebuf.offset).toBinary(), 'binary');
        const encryption_key = crypto_1.createHash('sha512').update(ebuf).digest();
        const iv = encryption_key.slice(32, 48);
        const tag = encryption_key.slice(0, 32);
        // check if first 64 bit of sha256 hash treated as uint64_t truncated to 32 bits.
        let checksum = crypto_1.createHash('sha256').update(encryption_key).digest();
        checksum = checksum.slice(0, 4);
        const cbuf = ByteBuffer.fromBinary(checksum.toString('binary'), ByteBuffer.LITTLE_ENDIAN);
        checksum = cbuf.readUint32();
        assert_1.default(check === checksum, 'Invalid nonce!');
        const binaryMessage = toUint8Array(encrypted);
        const decipher = crypto_1.createDecipheriv('aes-256-cbc', tag, iv);
        const decryptedMessage = Buffer.concat([decipher.update(binaryMessage), decipher.final()]);
        return removeVarintLengthPrefix(decryptedMessage);
    }
    catch (e) {
        throw e;
    }
};
/**
 * Encrypt a memo.
 *
 * @param memo - The memo to encrypt (need to start with #).
 * @param senderPrivateMemoKey - The private Memo key of the sender.
 * @param receiverPublicMemoKey - The publicKey Memo key of the recipient.
 * @returns The encrypted message.
 */
exports.encodeMemo = (memo, senderPrivateMemoKey, receiverPublicMemoKey) => {
    try {
        assert_1.default(typeof senderPrivateMemoKey === 'string' || senderPrivateMemoKey.toString(), 'Invalid Sender private MEMO key!');
        assert_1.default(typeof receiverPublicMemoKey === 'string' || receiverPublicMemoKey.toString(), 'Invalid Receiver public MEMO key!');
        if (!memo.startsWith('#')) {
            return memo;
        }
        const privateKey = typeof senderPrivateMemoKey === 'string' ? PrivateKey.from(senderPrivateMemoKey) : senderPrivateMemoKey;
        const publicKey = typeof receiverPublicMemoKey === 'string' ? PublicKey.from(receiverPublicMemoKey) : receiverPublicMemoKey;
        memo = memo.substring(1);
        const mbuf = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        mbuf.writeVString(memo);
        const memoBuff = Buffer.from(mbuf.flip().toBinary());
        const nonceLong = toByteBuffer(uniqueNonce());
        // Appending nonce to buffer "ebuf" and rehash with sha512
        const S = privateKey.getSharedSecret(publicKey);
        let ebuf = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        ebuf.writeUint64(nonceLong);
        ebuf.append(S.toString('binary'), 'binary');
        ebuf = Buffer.from(ebuf.copy(0, ebuf.offset).toBinary(), 'binary');
        const encryption_key = crypto_1.createHash('sha512').update(ebuf).digest();
        const iv = encryption_key.slice(32, 48);
        const tag = encryption_key.slice(0, 32);
        // check if first 64 bit of sha256 hash treated as uint64_t truncated to 32 bits.
        let check = crypto_1.createHash('sha256').update(encryption_key).digest();
        check = check.slice(0, 4);
        const cbuf = ByteBuffer.fromBinary(check.toString('binary'), ByteBuffer.LITTLE_ENDIAN);
        check = cbuf.readUint32();
        let message = toUint8Array(memoBuff);
        const cipher = crypto_1.createCipheriv('aes-256-cbc', tag, iv);
        message = Buffer.concat([cipher.update(message), cipher.final()]);
        const lbuf = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        serializer_1.Types.Memo(lbuf, {
            check,
            encrypted: message,
            from: privateKey.createPublic(),
            nonce: nonceLong,
            to: publicKey
        });
        lbuf.flip();
        const data = Buffer.from(lbuf.toBuffer());
        return '#' + bs58_1.default.encode(data);
    }
    catch (e) {
        throw e;
    }
};
/** Misc crypto utility functions. */
exports.cryptoUtils = {
    decodePrivate,
    doubleSha256,
    encodePrivate,
    encodePublic,
    generateTrxId,
    isCanonicalSignature,
    isWif,
    regExpAccount,
    regExpAtAccount,
    ripemd160,
    sha256,
    signTransaction,
    toBuffer,
    toByteBuffer,
    toUint8Array,
    transactionDigest,
    uniqueNonce
};
