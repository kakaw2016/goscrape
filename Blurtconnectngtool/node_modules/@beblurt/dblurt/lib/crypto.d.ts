/// <reference types="node" />
declare const Long: any;
import { SignedTransaction, Transaction } from './chain/transaction';
/**
 * ECDSA (secp256k1) public key.
 */
export declare class PublicKey {
    readonly key: Buffer;
    readonly prefix: string;
    readonly uncompressed: Buffer;
    constructor(key: Buffer, prefix?: string);
    /**
     * Create a new instance from a WIF-encoded key.
     */
    static fromString(wif: string): PublicKey;
    static fromBuffer(key: Buffer): {
        key: Buffer;
    };
    /**
     * Create a new instance.
     */
    static from(value: string | PublicKey): PublicKey;
    /**
     * Verify a 32-byte signature.
     * @param message 32-byte message to verify.
     * @param signature Signature to verify.
     */
    verify(message: Buffer, signature: Signature): boolean;
    /**
     * Return a WIF-encoded representation of the key.
     */
    toString(): string;
    /**
     * Return JSON representation of this key, same as toString().
     */
    toJSON(): string;
    /**
     * Used by `utils.inspect` and `console.log` in node.js.
     */
    inspect(): string;
}
export declare type KeyRole = 'owner' | 'active' | 'posting' | 'memo';
/**
 * ECDSA (secp256k1) private key.
 */
export declare class PrivateKey {
    private key;
    constructor(key: Buffer);
    /**
     * Convenience to create a new instance from WIF string or buffer.
     */
    static from(value: string | Buffer): PrivateKey;
    /**
     * Create a new instance from a WIF-encoded key.
     */
    static fromString(wif: string): PrivateKey;
    /**
     * Create a new instance from a seed.
     */
    static fromSeed(seed: string): PrivateKey;
    /**
     * Create key from username and password.
     */
    static fromLogin(username: string, password: string, role?: KeyRole): PrivateKey;
    /**
     * Sign message.
     * @param message 32-byte message.
     */
    sign(message: Buffer): Signature;
    /**
     * Derive the public key for this private key.
     */
    createPublic(prefix?: string): PublicKey;
    /**
     * Return a WIF-encoded representation of the key.
     */
    toString(): string;
    /**
     * Get shared secret for memo cryptography
     */
    getSharedSecret(publicKey: PublicKey): Buffer;
    /**
     * Used by `utils.inspect` and `console.log` in node.js. Does not show the full key
     * to get the full encoded key you need to explicitly call {@link toString}.
     */
    inspect(): string;
}
/**
 * ECDSA (secp256k1) signature.
 */
export declare class Signature {
    data: Buffer;
    recovery: number;
    constructor(data: Buffer, recovery: number);
    static fromBuffer(buffer: Buffer): Signature;
    static fromString(string: string): Signature;
    /**
     * Recover public key from signature by providing original signed message.
     * @param message 32-byte message that was used to create the signature.
     */
    recover(message: Buffer, prefix?: string): PublicKey;
    toBuffer(): Buffer;
    toString(): string;
}
/**
 * Decrypts an encrypted memo.
 *
 * @param memo - The encrypted memo to decrypt (need to start with #).
 * @param receiverPrivateMemoKey - The private Memo key of the recipient.
 * @returns The decrypted message.
 */
export declare const decodeMemo: (memo: string, receiverPrivateMemoKey: PrivateKey | string) => string;
/**
 * Encrypt a memo.
 *
 * @param memo - The memo to encrypt (need to start with #).
 * @param senderPrivateMemoKey - The private Memo key of the sender.
 * @param receiverPublicMemoKey - The publicKey Memo key of the recipient.
 * @returns The encrypted message.
 */
export declare const encodeMemo: (memo: string, senderPrivateMemoKey: PrivateKey | string, receiverPublicMemoKey: PublicKey | string) => string;
/** Misc crypto utility functions. */
export declare const cryptoUtils: {
    decodePrivate: (encodedKey: string) => Buffer;
    doubleSha256: (input: Buffer | string) => Buffer;
    encodePrivate: (key: Buffer) => string;
    encodePublic: (key: Buffer, prefix: string) => string;
    generateTrxId: (transaction: Transaction) => string;
    isCanonicalSignature: (signature: Buffer) => boolean;
    isWif: (privWif: string) => boolean;
    regExpAccount: RegExp;
    regExpAtAccount: RegExp;
    ripemd160: (input: Buffer | string) => Buffer;
    sha256: (input: Buffer | string) => Buffer;
    signTransaction: (transaction: Transaction, keys: any, chainId?: Buffer) => SignedTransaction;
    toBuffer: (ab: ArrayBuffer) => Buffer;
    toByteBuffer: (o: string | number | typeof Long) => typeof Long;
    toUint8Array: (buf: Buffer) => Uint8Array;
    transactionDigest: (transaction: Transaction | SignedTransaction, chainId?: Buffer) => Buffer;
    uniqueNonce: () => string;
};
export {};
